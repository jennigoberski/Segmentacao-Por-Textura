# -*- coding: utf-8 -*-
"""Trabalho 1 - Processamento de Imagens

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13zuYcqb_min3AZJUpJAk-vTSJbIm4myL

# Segmentação por Textura
*Disciplina:* Tópicos em Processamento de Imagens <br>
*Professor:* Eduardo Todt <br>

**Nome:** Jennifer Mayara de Paiva Goberski <br>
**Matrícula:** INFORMÁTICA - 40001016034P5

# Parte 0 - Imports
"""

import os
import cv2
import glob
import numpy as np
from scipy.ndimage import zoom
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from matplotlib.patches import Patch
from scipy.ndimage import gaussian_filter
from sklearn.preprocessing import StandardScaler

"""

```
# Acessando a pasta do drive
```

"""

from google.colab import drive
drive.mount('/content/drive')

"""# Parte 1 - Manipulando as Imagens

```
# Importando as imagens de jardim da pasta, contando o número total
 de amostras e exibindo alguns exemplos
```
"""

image_folder = '/content/drive/MyDrive/Trabalho 1/jardins'

image_paths = sorted(glob.glob(os.path.join(image_folder, '*.jpg')) +
                     glob.glob(os.path.join(image_folder, '*.jpeg')) +
                     glob.glob(os.path.join(image_folder, '*.png')))

print(f"Total de imagens: {len(image_paths)}")

plt.figure(figsize=(15, 5))
for i in range(3):
    img = cv2.imread(image_paths[i])
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    plt.subplot(1, 3, i + 1)
    plt.imshow(img_rgb)
    plt.title(f"Imagem {i+1}")
    plt.axis("off")

plt.tight_layout()
plt.show()

"""

```
# Trocar a escala de cores de RGB para HSV

*H* -> hue (matiz)
*S* -> saturação
*V* -> value (valor da cor, ou seja, seu brilho)
```

"""

plt.figure(figsize=(15, 10))

for i in range(3):
    img = cv2.imread(image_paths[i])

    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    h, s, v = cv2.split(img_hsv)

    plt.subplot(3, 5, i * 5 + 1)
    plt.imshow(img_rgb)
    plt.title(f"Imagem {i + 1} (RGB)")
    plt.axis("off")

    plt.subplot(3, 5, i * 5 + 2)
    plt.imshow(img_hsv)
    plt.title(f"Imagem {i + 1} (HSV)")
    plt.axis("off")

    plt.subplot(3, 5, i * 5 + 3)
    plt.imshow(h, cmap='hsv')
    plt.title(f"Canal H - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 5, i * 5 + 4)
    plt.imshow(s, cmap='gray')
    plt.title(f"Canal S - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 5, i * 5 + 5)
    plt.imshow(v, cmap='gray')
    plt.title(f"Canal V - Imagem {i + 1}")
    plt.axis("off")

plt.tight_layout()
plt.show()

"""# Parte 2 - Extração de Características Locais Usando Filtros

```
# Criação de filtros

1.   Vertical
2.   Horizontal
3.   45°
4.   135°
5.   Cicular
```

```
# Definindo os filtros
```
"""

# Filtro Vertical
plt.figure(figsize=(15, 10))

for i in range(3):
    img = cv2.imread(image_paths[i])

    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    v = img_hsv[:, :, 2]

    # Aplicar filtro Sobel vertical (dx=0, dy=1)
    sobel_y = cv2.Sobel(v, ddepth=cv2.CV_64F, dx=0, dy=1, ksize=3)
    sobel_y = np.absolute(sobel_y)
    sobel_y = np.uint8(np.clip(sobel_y, 0, 255))

    img_hsv_filtered = img_hsv.copy()
    img_hsv_filtered[:, :, 2] = sobel_y

    plt.subplot(3, 3, 3*i + 1)
    plt.imshow(img_rgb)
    plt.title(f"Original RGB - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 3, 3*i + 2)
    plt.imshow(v, cmap='gray')
    plt.title(f"Canal V Original - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 3, 3*i + 3)
    plt.imshow(sobel_y, cmap='gray')
    plt.title(f"Sobel Vertical - Imagem {i + 1}")
    plt.axis("off")

plt.tight_layout()
plt.show()

# Filtro Horizontal
plt.figure(figsize=(15, 10))

for i in range(3):
    img = cv2.imread(image_paths[i])

    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    v = img_hsv[:, :, 2]

    # Aplicar filtro Sobel horizontal (dx=1, dy=0)
    sobel_x = cv2.Sobel(v, ddepth=cv2.CV_64F, dx=1, dy=0, ksize=3)
    sobel_x = np.absolute(sobel_x)
    sobel_x = np.uint8(np.clip(sobel_x, 0, 255))

    img_hsv_filtered = img_hsv.copy()
    img_hsv_filtered[:, :, 2] = sobel_x

    plt.subplot(3, 3, 3*i + 1)
    plt.imshow(img_rgb)
    plt.title(f"Original RGB - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 3, 3*i + 2)
    plt.imshow(v, cmap='gray')
    plt.title(f"Canal V Original - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 3, 3*i + 3)
    plt.imshow(sobel_x, cmap='gray')
    plt.title(f"Sobel Horizontal - Imagem {i + 1}")
    plt.axis("off")

plt.tight_layout()
plt.show()

# Filtro 45° (Diagonal Ascendente)
kernel_45deg = np.array([[ 0, -1, -1],
                         [ 1,  0, -1],
                         [ 1,  1,  0]])

plt.figure(figsize=(15, 10))

for i in range(3):
    img = cv2.imread(image_paths[i])

    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    v = img_hsv[:,:,2]

    v_filtered = cv2.filter2D(v, -1, kernel_45deg)
    v_filtered = np.clip(v_filtered, 0, 255).astype(np.uint8)

    img_hsv_filtered = img_hsv.copy()
    img_hsv_filtered[:,:,2] = v_filtered

    plt.subplot(3, 3, 3*i + 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title(f"Original RGB - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 3, 3*i + 2)
    plt.imshow(img_hsv[:,:,2], cmap='gray')
    plt.title(f"Canal V Original - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 3, 3*i + 3)
    plt.imshow(v_filtered, cmap='gray')
    plt.title(f"Filtro 45° Aplicado - Imagem {i + 1}")
    plt.axis("off")

plt.tight_layout()
plt.show()

# Filtro 135° (Diagonal Descendente)
kernel_135deg = np.array([[-1, -1,  0],
                          [-1,  0,  1],
                          [ 0,  1,  1]])

plt.figure(figsize=(15, 10))

for i in range(3):
    img = cv2.imread(image_paths[i])

    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    v = img_hsv[:,:,2]

    v_filtered = cv2.filter2D(v, -1, kernel_135deg)
    v_filtered = np.clip(v_filtered, 0, 255).astype(np.uint8)

    img_hsv_filtered = img_hsv.copy()
    img_hsv_filtered[:,:,2] = v_filtered

    plt.subplot(3, 3, 3*i + 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title(f"Original RGB - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 3, 3*i + 2)
    plt.imshow(img_hsv[:,:,2], cmap='gray')
    plt.title(f"Canal V Original - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 3, 3*i + 3)
    plt.imshow(v_filtered, cmap='gray')
    plt.title(f"Filtro 135° Aplicado - Imagem {i + 1}")
    plt.axis("off")

plt.tight_layout()
plt.show()

# Filtro Circular (Laplace)
plt.figure(figsize=(15, 10))

for i in range(3):
    img = cv2.imread(image_paths[i])

    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    v = img_hsv[:, :, 2]

    v_filtered = cv2.Laplacian(v, ddepth=cv2.CV_64F)
    v_filtered = np.absolute(v_filtered)
    v_filtered = np.clip(v_filtered, 0, 255).astype(np.uint8)

    img_hsv_filtered = img_hsv.copy()
    img_hsv_filtered[:, :, 2] = v_filtered

    plt.subplot(3, 3, 3*i + 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title(f"Original RGB - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 3, 3*i + 2)
    plt.imshow(v, cmap='gray')
    plt.title(f"Canal V Original - Imagem {i + 1}")
    plt.axis("off")

    plt.subplot(3, 3, 3*i + 3)
    plt.imshow(v_filtered, cmap='gray')
    plt.title(f"Laplaciano - Imagem {i + 1}")
    plt.axis("off")

plt.tight_layout()
plt.show()

"""# Parte 3 -> Lidando com Escalas Dinamicamente

*   Redimensionar a imagem, e não os filtros em si
*   Aplicar o conjunto de filtros em cada escala da imagem

```
# Filtro Gaussiano é aplicado na imagem, depois sua dimensão é reduzida pela metade
```
"""

def apply_gaussian_and_reduce(image, scale_factor):
    # Aplica o desfoque gaussiano
    blurred_image = cv2.GaussianBlur(image, (5, 5), 0)

    # Reduz a imagem de acordo com o fator de escala
    new_dims = (int(image.shape[1] * scale_factor), int(image.shape[0] * scale_factor))
    reduced_image = cv2.resize(blurred_image, new_dims, interpolation=cv2.INTER_LINEAR)

    return reduced_image

# Exemplo da diferença de cada escala aplicada nas imagens
scales = [1.0, 0.5, 0.25]
scale_names = ['Escala 1.0', 'Escala 0.5', 'Escala 0.25']

fig, axes = plt.subplots(3, 3, figsize=(12, 12))

for i in range(3):
    img = cv2.imread(image_paths[i])
    for j, scale in enumerate(scales):
        reduced_img = apply_gaussian_and_reduce(img, scale)
        img_rgb = cv2.cvtColor(reduced_img, cv2.COLOR_BGR2RGB)

        canvas = np.ones((img.shape[0], img.shape[1], 3), dtype=np.uint8) * 255
        h, w = reduced_img.shape[:2]
        y_offset = (canvas.shape[0] - h) // 2
        x_offset = (canvas.shape[1] - w) // 2
        canvas[y_offset:y_offset+h, x_offset:x_offset+w] = reduced_img

        canvas_rgb = cv2.cvtColor(canvas, cv2.COLOR_BGR2RGB)
        axes[i, j].imshow(canvas_rgb)
        axes[i, j].set_title(f"Imagem {i+1} - {scale_names[j]}", fontsize=10)
        axes[i, j].axis("off")

plt.tight_layout()
plt.show()

"""# Parte 4 -> Extração de Características Locais"""

def apply_gaussian_and_resize(image, kernel_size=(3, 3), sigma=0):
    smoothed_image = cv2.GaussianBlur(image, kernel_size, sigma)
    resized_image = cv2.resize(smoothed_image, (0, 0), fx=0.5, fy=0.5)

    return resized_image

def extract_texture_vector(image, window_size):
    """
    Extrai um vetor de textura baseado na média de cada janela da imagem.
    A saída é normalizada para o intervalo [0, 255] e convertida para inteiros.
    """
    height, width = image.shape
    texture_vector = []

    for i in range(0, height - window_size + 1, window_size):
        for j in range(0, width - window_size + 1, window_size):
            window = image[i:i + window_size, j:j + window_size]
            window_mean = np.mean(window)
            texture_vector.append(window_mean)

    texture_vector = np.array(texture_vector, dtype=np.float32)

    min_val = texture_vector.min()
    max_val = texture_vector.max()

    if max_val > min_val:
        texture_vector = 255 * (texture_vector - min_val) / (max_val - min_val)
    else:
        texture_vector = np.zeros_like(texture_vector)

    return texture_vector.astype(np.uint8)

def apply_filters(image, window_size=3):
    """
    Aplica filtros em uma imagem e extrai vetores de textura com base na média de cada janela.
    Aplica suavização prévia para melhorar a qualidade das respostas dos filtros.
    """
    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    v_channel = hsv_image[:, :, 2]

    v_blurred = gaussian_filter(v_channel, sigma=1)

    filters = {
        "Vertical": np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]]),
        "Horizontal": np.array([[-1, -1, -1], [0,  0,  0], [1,  1,  1]]),
        "Circular": np.array([[0, -1,  0], [-1,  4, -1], [0, -1,  0]]),
        "45 Graus": np.array([[ 0, -1, -1], [ 1,  0, -1], [ 1,  1,  0]]),
        "135 Graus": np.array([[-1, -1,  0], [-1,  0,  1], [ 0,  1,  1]])
    }

    filtered_images = {}
    texture_vectors_by_filter = {}

    for filter_name, kernel in filters.items():
        filtered = cv2.filter2D(v_blurred, -1, kernel)

        filtered = np.clip(filtered, 0, 255).astype(np.uint8)

        texture_vector = extract_texture_vector(filtered, window_size)

        filtered_images[filter_name] = filtered
        texture_vectors_by_filter[filter_name] = texture_vector

    return filtered_images, texture_vectors_by_filter

def process_scales(images, scales, window_size):
    all_texture_vectors = []

    for i, image in enumerate(images):
        image_vectors_by_scale = []
        for scale, scale_name in zip(scales, scale_names):
            print(f"[LOG] Processando Escala {scale_name}: Figura {i + 1}")

            resized_image = cv2.resize(image, None, fx=scale, fy=scale, interpolation=cv2.INTER_LINEAR)
            print(f"[LOG] Figura {i + 1} redimensionada para a escala {scale} após suavização Gaussiana.")

            filtered_images, texture_vectors_by_filter = apply_filters(resized_image, window_size)

            scale_vectors = []
            for filter_name, texture_vector in texture_vectors_by_filter.items():
                print(f"[LOG] Figura {i + 1}, Filtro {filter_name}: Características coletadas. Tamanho do vetor: {texture_vector.shape}")
                scale_vectors.append(texture_vector)

            image_vectors_by_scale.append(scale_vectors)

        all_texture_vectors.append(image_vectors_by_scale)

    return all_texture_vectors

# Função para exibir as imagens com os filtros aplicados
def display_filtered_images(images, filters):
    fig, axes = plt.subplots(len(images), len(filters) + 1, figsize=(15, len(images) * 5))

    for i, image in enumerate(images):
        # Exibe a imagem original
        axes[i, 0].imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
        axes[i, 0].set_title(f"Imagem Original {i + 1}", fontsize=12)
        axes[i, 0].axis('off')

        # Exibe as imagens filtradas
        for j, (filter_name, filtered_img) in enumerate(filters.items()):
            axes[i, j + 1].imshow(filtered_img, cmap='gray')
            axes[i, j + 1].set_title(f"{filter_name}", fontsize=10)
            axes[i, j + 1].axis('off')

    plt.tight_layout()
    plt.show()

images_to_process = [cv2.imread(path) for path in image_paths]

for i in range(2):
    img = images_to_process[i]
    filtered_images, texture_vectors = apply_filters(img)

    fig, axes = plt.subplots(1, len(filtered_images), figsize=(15, 4))
    fig.suptitle(f"Imagem {i + 1} com diferentes filtros", fontsize=14)

    for ax, (filter_name, filtered_img) in zip(axes, filtered_images.items()):
        ax.imshow(filtered_img, cmap='gray')
        ax.set_title(filter_name)
        ax.axis('off')

    plt.tight_layout()
    plt.show()

images_to_process = [cv2.imread(path) for path in image_paths]

# Escalas e nomes
scales = [1.0, 0.5, 0.25]
scale_names = ['Escala 1.0', 'Escala 0.5', 'Escala 0.25']
window_size = 3

# Processamento de todas as escalas e imagens
all_texture_vectors = process_scales(images_to_process, scales=scales, window_size=window_size)

print("\nEstrutura de vetores de características coletados para cada imagem, escala e filtro:")
for i, image_scales in enumerate(all_texture_vectors):
    print(f"Imagem {i + 1}:")
    for j, scale_vectors in enumerate(image_scales):
        print(f"  Escala {scale_names[j]}:")
        for k, vector in enumerate(scale_vectors):
            print(f"    Vetor Filtro {k + 1}: {vector.shape}")

"""# Parte 5 -> Clusters e Segmentação"""

def segment(image, scales, window_size=3, n_clusters=3):
    for scale in scales:
        resized = cv2.resize(image, None, fx=scale, fy=scale, interpolation=cv2.INTER_LINEAR)
        filtered_images, texture_vectors = apply_filters(resized, window_size)

        h, w = resized.shape[:2]
        seg_h = h // window_size
        seg_w = w // window_size

        imagens_resultado = []
        titulos_resultado = []

        img_original_rgb = cv2.cvtColor(resized, cv2.COLOR_BGR2RGB)
        imagens_resultado.append(img_original_rgb)
        titulos_resultado.append(f"Original\nEscala {scale}")

        # Segmentações individuais por filtro
        for filtro, vetor in texture_vectors.items():
            vetor = vetor.reshape(-1, 1)
            vetor = StandardScaler().fit_transform(vetor)
            labels = KMeans(n_clusters=n_clusters, random_state=0).fit_predict(vetor)
            segmented = labels.reshape((seg_h, seg_w))
            segmented_color = cv2.applyColorMap((255 * segmented / segmented.max()).astype(np.uint8), cv2.COLORMAP_VIRIDIS )
            segmented_rgb = cv2.cvtColor(segmented_color, cv2.COLOR_BGR2RGB)

            imagens_resultado.append(segmented_rgb)
            titulos_resultado.append(f"{filtro}")

        # Segmentação combinada
        all_features = np.column_stack([
            StandardScaler().fit_transform(vec.reshape(-1, 1))
            for vec in texture_vectors.values()
        ])
        labels_combined = KMeans(n_clusters=n_clusters, random_state=0).fit_predict(all_features)
        segmented_combined = labels_combined.reshape((seg_h, seg_w))
        segmented_color_combined = cv2.applyColorMap((255 * segmented_combined / segmented_combined.max()).astype(np.uint8), cv2.COLORMAP_VIRIDIS)
        segmented_combined_rgb = cv2.cvtColor(segmented_color_combined, cv2.COLOR_BGR2RGB)

        imagens_resultado.append(segmented_combined_rgb)
        titulos_resultado.append("Combinado")

        plt.figure(figsize=(20, 4))
        for idx, img in enumerate(imagens_resultado):
            plt.subplot(1, len(imagens_resultado), idx + 1)
            plt.imshow(img)
            plt.title(titulos_resultado[idx], fontsize=9)
            plt.axis("off")
        plt.tight_layout()
        plt.show()

images_to_process = [cv2.imread(path) for path in image_paths]
scales = [1.0, 0.5, 0.25]

for idx, image in enumerate(images_to_process):
    print(f"\nProcessando imagem {idx + 1}/{len(images_to_process)}...")
    segment(image, scales, window_size=3, n_clusters=3)